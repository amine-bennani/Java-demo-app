# .gitlab-ci.yml

# Use a Docker-in-Docker image to build and push container images.
# Alternatively, create a custom Docker image that includes Node, Docker, kubectl, gcloud, etc.
image: docker:20.10.16-dind

services:
  - docker:20.10.16-dind

variables:
  # Enable docker-in-docker
  DOCKER_TLS_CERTDIR: "/certs"
  # Use overlay2 driver for Docker
  DOCKER_DRIVER: overlay2

stages:
  - build
  - test
  - coverage_check
  - docker_build
  - deploy_staging
  - selenium_test
  - deploy_production

#-----------------------------------
# Stage 1: Build
#-----------------------------------
build_app:
  stage: build
  # A shell executor on your self-hosted runner that has Node installed
  # or you can run in a Docker image that has Node by overriding 'image:' here
  script:
    - echo "Building the application..."
    - npm ci          # install dependencies
    - npm run build   # if you have a build script
  artifacts:
    name: "build-artifacts"
    paths:
      - node_modules/
      - dist/         # or wherever your build outputs go
    expire_in: 1 hour

#-----------------------------------
# Stage 2: Unit Tests
#-----------------------------------
test_app:
  stage: test
  dependencies:
    - build_app
  script:
    - echo "Running unit tests..."
    - npm test        # or npm run test
  artifacts:
    name: "test-artifacts"
    paths:
      - coverage/     # store coverage results
    expire_in: 1 hour

#-----------------------------------
# Stage 3: Coverage Check
#-----------------------------------
coverage_check:
  stage: coverage_check
  dependencies:
    - test_app
  script:
    - echo "Checking coverage results..."
    # Example: parse coverage/summary.json or an lcov file to ensure coverage >80%
    # This is pseudocode. Adjust to your coverage tool's output format.
    - coverageValue=$(grep -Po '"lines":{"total":\K[0-9]*' coverage/coverage-summary.json) # example for Istanbul
    - echo "Coverage is $coverageValue%"
    - if [ "$coverageValue" -lt "80" ]; then
        echo "Coverage is below 80%! Failing...";
        exit 1;
      fi
  # Only proceed if coverage >= 80%

#-----------------------------------
# Stage 4: Docker Build & Push
#-----------------------------------
docker_build:
  stage: docker_build
  dependencies:
    - coverage_check
  script:
    - echo "Logging into Docker registry..."
    - docker login -u "$DOCKER_USER" -p "$DOCKER_PASS"
    - echo "Building Docker image..."
    - docker build -t "$DOCKER_USER/my-demo-app:$CI_COMMIT_SHORT_SHA" .
    - docker push "$DOCKER_USER/my-demo-app:$CI_COMMIT_SHORT_SHA"
  only:
    - main  # or your default branch

#-----------------------------------
# Stage 5: Deploy to Minikube (Staging)
#-----------------------------------
deploy_staging:
  stage: deploy_staging
  dependencies:
    - docker_build
  script:
    # Ensure minikube is up (assuming your runner has "minikube start" done before)
    - echo "Deploying to local Minikube..."
    # If you're using direct kubectl
    - kubectl create deployment my-app-staging --image="$DOCKER_USER/my-demo-app:$CI_COMMIT_SHORT_SHA" || kubectl set image deployment/my-app-staging my-app-staging="$DOCKER_USER/my-demo-app:$CI_COMMIT_SHORT_SHA"
    # Expose it via NodePort for test
    - kubectl expose deployment my-app-staging --type=NodePort --port=3000 || echo "Service may already exist"
    # Wait for pods to be ready
    - kubectl rollout status deployment/my-app-staging --timeout=120s
    - kubectl get pods
  only:
    - main

#-----------------------------------
# Stage 6: Selenium Tests
#-----------------------------------
selenium_test:
  stage: selenium_test
  dependencies:
    - deploy_staging
  script:
    - echo "Running Selenium tests against staging environment..."
    # Example: find the NodePort
    - STAGING_NODE_PORT=$(kubectl get svc my-app-staging -o jsonpath='{.spec.ports[0].nodePort}')
    - MINIKUBE_IP=$(minikube ip)
    - export STAGING_URL="http://$MINIKUBE_IP:$STAGING_NODE_PORT"
    - echo "Staging URL is $STAGING_URL"
    # Example command: run a Selenium test suite pointing to $STAGING_URL
    - npm install -g selenium-webdriver # or your test runner
    - run-selenium-tests --baseUrl="$STAGING_URL"
  only:
    - main

#-----------------------------------
# Stage 7: Deploy to GCP (Production)
#-----------------------------------
deploy_production:
  stage: deploy_production
  dependencies:
    - selenium_test
  script:
    - echo "Deploying to GCP..."
    # Example for GKE:
    - echo "$GCP_SERVICE_ACCOUNT_JSON" > /tmp/gcp-key.json
    - gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
    - gcloud config set project $GCP_PROJECT_ID
    - gcloud container clusters get-credentials $GCP_CLUSTER_NAME --zone $GCP_CLUSTER_ZONE
    # Then apply or update the deployment in GKE:
    - kubectl create deployment my-app-production --image="$DOCKER_USER/my-demo-app:$CI_COMMIT_SHORT_SHA" || \
      kubectl set image deployment/my-app-production my-app-production="$DOCKER_USER/my-demo-app:$CI_COMMIT_SHORT_SHA"
    - kubectl expose deployment my-app-production --type=LoadBalancer --port=80 || echo "Service may already exist"
    - kubectl rollout status deployment/my-app-production --timeout=120s
    - kubectl get pods
  environment:
    name: production
  only:
    - main

